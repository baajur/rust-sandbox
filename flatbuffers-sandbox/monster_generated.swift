// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public enum MyGame {
public enum Sample {

public enum Color: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case red = 0
	case green = 1
	case blue = 2


	public static var max: Color { return .blue }
	public static var min: Color { return .red }
}

public enum Equipment: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case weapon = 1


	public static var max: Equipment { return .weapon }
	public static var min: Equipment { return .none }
}

public struct Vec3: Readable {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Struct
	public static var size = 12
	public static var alignment = 4	
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

	public var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
	public var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
	public var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
}

public static func createVec3(x: Float32, y: Float32, z: Float32) -> UnsafeMutableRawPointer {
	let memory = UnsafeMutableRawPointer.allocate(byteCount: Vec3.size, alignment: Vec3.alignment)
	memory.initializeMemory(as: UInt8.self, repeating: 0, count: Vec3.size)
	memory.storeBytes(of: x, toByteOffset: 0, as: Float32.self)
	memory.storeBytes(of: y, toByteOffset: 4, as: Float32.self)
	memory.storeBytes(of: z, toByteOffset: 8, as: Float32.self)
	return memory
}

public struct Monster: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsMonster(bb: ByteBuffer) -> Monster { return Monster(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var pos: MyGame.Sample.Vec3? { let o = _accessor.offset(4); return o == 0 ? nil : MyGame.Sample.Vec3(_accessor.bb, o: o + _accessor.postion) }
	public var mana: Int16 { let o = _accessor.offset(6); return o == 0 ? 150 : _accessor.readBuffer(of: Int16.self, at: o) }
	public var hp: Int16 { let o = _accessor.offset(8); return o == 0 ? 100 : _accessor.readBuffer(of: Int16.self, at: o) }
	public var name: String? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 10) }
	public var inventoryCount: Int32 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func inventory(at index: Int32) -> UInt8 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
	public var inventory: [UInt8] { return _accessor.getVector(at: 14) ?? [] }
	public var color: MyGame.Sample.Color { let o = _accessor.offset(16); return o == 0 ? .blue : MyGame.Sample.Color(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .blue }
	public var weaponsCount: Int32 { let o = _accessor.offset(18); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func weapons(at index: Int32) -> MyGame.Sample.Weapon? { let o = _accessor.offset(18); return o == 0 ? nil : MyGame.Sample.Weapon(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var equippedType: MyGame.Sample.Equipment { let o = _accessor.offset(20); return o == 0 ? .none : MyGame.Sample.Equipment(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func equipped<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(22); return o == 0 ? nil : _accessor.union(o) }
	public var pathCount: Int32 { let o = _accessor.offset(24); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func path(at index: Int32) -> MyGame.Sample.Vec3? { let o = _accessor.offset(24); return o == 0 ? nil : MyGame.Sample.Vec3(_accessor.bb, o: _accessor.vector(at: o) + index * 12) }
	public static func startMonster(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
	public static func add(pos: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(structOffset: 0) }
	public static func add(mana: Int16, _ fbb: FlatBufferBuilder) { fbb.add(element: mana, def: 150, at: 1) }
	public static func add(hp: Int16, _ fbb: FlatBufferBuilder) { fbb.add(element: hp, def: 100, at: 2) }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 3)  }
	public static func addVectorOf(inventory: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: inventory, at: 5)  }
	public static func add(color: MyGame.Sample.Color, _ fbb: FlatBufferBuilder) { fbb.add(element: color.rawValue, def: 2, at: 6) }
	public static func addVectorOf(weapons: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: weapons, at: 7)  }
	public static func add(equippedType: MyGame.Sample.Equipment, _ fbb: FlatBufferBuilder) { fbb.add(element: equippedType.rawValue, def: 0, at: 8) }
	public static func add(equipped: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: equipped, at: 9)  }
	public static func addVectorOf(path: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: path, at: 10)  }
	public static func endMonster(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createMonster(_ fbb: FlatBufferBuilder,
		offsetOfPos pos: Offset<UOffset> = Offset(),
		mana: Int16 = 150,
		hp: Int16 = 100,
		offsetOfName name: Offset<String> = Offset(),
		vectorOfInventory inventory: Offset<UOffset> = Offset(),
		color: MyGame.Sample.Color = .blue,
		vectorOfWeapons weapons: Offset<UOffset> = Offset(),
		equippedType: MyGame.Sample.Equipment = .none,
		offsetOfEquipped equipped: Offset<UOffset> = Offset(),
		vectorOfPath path: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Monster.startMonster(fbb)
		Monster.add(pos: pos, fbb)
		Monster.add(mana: mana, fbb)
		Monster.add(hp: hp, fbb)
		Monster.add(name: name, fbb)
		Monster.addVectorOf(inventory: inventory, fbb)
		Monster.add(color: color, fbb)
		Monster.addVectorOf(weapons: weapons, fbb)
		Monster.add(equippedType: equippedType, fbb)
		Monster.add(equipped: equipped, fbb)
		Monster.addVectorOf(path: path, fbb)
		return Monster.endMonster(fbb, start: __start)
	}
}

public struct Weapon: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsWeapon(bb: ByteBuffer) -> Weapon { return Weapon(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var name: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var damage: Int16 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
	public static func startWeapon(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 0)  }
	public static func add(damage: Int16, _ fbb: FlatBufferBuilder) { fbb.add(element: damage, def: 0, at: 1) }
	public static func endWeapon(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createWeapon(_ fbb: FlatBufferBuilder,
		offsetOfName name: Offset<String> = Offset(),
		damage: Int16 = 0) -> Offset<UOffset> {
		let __start = Weapon.startWeapon(fbb)
		Weapon.add(name: name, fbb)
		Weapon.add(damage: damage, fbb)
		return Weapon.endWeapon(fbb, start: __start)
	}
}

}

// MARK: - Sample

}

// MARK: - MyGame


